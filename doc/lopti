LOPTI - C++ optimization library.
=================================
Leonid Volnitsky <leonid@volnitsky.com>
v0.2 Nov 2008

WARNING: This document is work in progress, only about 20% is complete and there is no logical sequence yet.

+++<div style="float: right; margin-left: 2em">+++
image:xgr001.gif["Visualization with xgraphics", width="400", link="xgr001.gif"]

LOPTI is open source C++ optimization library. There are three major parts.
1st and main part is solver-driver which either wraps external solver or uses
LOPTI native solvers and presents to library user consistent and simple
optimization API.  2nd part is collection of solvers.  All current solver are
open source (GPL or BSD like licences).  Some of them (Condor) are unchanged
and treated as black-box.  Some of them (NEWUOA - fortran source) went through
heavy modification to interface with LOPTI.  And other (Hook-Jeevs) were
completely rewritten into LOPTI native solver.  3rd part is collection of
object function and object function modifiers. 
+++</div>+++

.Available Solvers
[grid="all"]
`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~.~~~~~~~~~~~~~.~~~~~~~~~~~~~~~`~~~~~~~~~~~~~~~~~~~~~~~~~~~`~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Solver                         , Type        , Use Derivative, Origin                   , Dependency
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Condor                         , Trust Region, No            , "Based on Powel's UOBYQA",                       "Source available at http://XXXXXXXXXXX.com"
NEWUOA                         , Trust Region, No            , "2002, latest from Powel, successor to UOBYQA",   "none (converted fortran source included)"
GSL Nelder-Mead (Simplex)      , Direct      , No            , "1965<<1>>"                                     , "GNU Scientific Library (package available for most linux distro)"
Hook-Jeevs                     , Direct      , No            , "1962, C implementation by Sergey Kiselev"      , "none (converted to native LOPTI implementation)"
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Sample use:

[c]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
include::example.cc[]
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

== LOFT
Object function are so called Lopti Object FuncTor (LOFT)  which are callable objects either representing object function
or wrapper for other LOFTs.  LOFT allow to wrap object
function in any number and combination of LOFT, such as rescaler, logger, noise-adder,
adapter, constrain-adder-by-barrier-function,  etc. 

=== make_loft() - create loft from any callable object
`make_loft(loft l,)` +

TODO: write

=== trace() - pregress tracer
`trace(loft l,)` +

Prints on screen eval-number, seconds of last eval, X and f-value

=== xg_log() - xgraphic logger
`xg_log(loft l, minimizer<V> m)` +

Logs eval-numer, f-value and X on every loft evaluation. Programm `xgraphic` is
open source visualization utility with can be dirctly input this file.  Log
file name is composed from loft name and minimizer name and file creaded under `./log/`

=== rescale() - normalizer
`rescale<V>(loft L, V rescale_vector)` +

Most solvers work much better if function first drivative (and second?) have
about the same order in all directions.  `rescale` convert wrapped loft
function into such nomalized function with rescaling
vector.  When solver request to evaluate loft on X, `rescale` gives wrapped
loft(real object function),  vector  X*rescale_vector. When you use `rescale`,
don't forget to rescale X0 too:  X0 = X0/rescale_vector



== TODO
- docs
- convert dependacy from `lvv::array` to `boost::array`
- remove all depenancies on <lvv/*.h>
- remove `using` from headers
- add `zib nlqe1` solver
- add `zib newton_test` funtions
- add `gsl bfgs` solver
- add `assert` / `throw` on use uninilized data in `minimizer` class

== References
+ [[[1]]] J.A. Nelder and R. Mead, 'A simplex method for function minimization', Computer Journal vol. 7 (1965), 308-315.

// vim: set filetype=asciidoc nu:
