LOPTI - C++ optimization library.
=================================
Leonid Volnitsky <leonid@volnitsky.com>
v0.2 (alpha) Nov 2008
:icons: Yes
:iconsdir: /
:language: cpp
:caption:
:compact-option: compact

//:iconsdir: /etc/asciidoc/images/icons/
+++<div style="float: right; margin-left: 2em">+++
image:xgr001.gif["Visualization with xgraphics", width="400", link="xgr001.gif"]

LOPTI is open source C++ optimization library. There are three major parts.
1st and main part is solver-driver which either wraps external solver or uses
LOPTI native solvers and presents to library user consistent and simple
optimization API. 2nd part is collection of solvers.  Currently included with LOPTI are 4
solvers: <<NEWUOA,NEWUOA>>, <<CONDOR,CONDOR>>, <<Nelder-Mead,Nelder-Mead>> (simplex) and <<Hook-Jeevs,Hook-Jeevs>>.
All these solvers are derivative free and have open source (GPL or BSD like)
licences.  Some of them (Condor) are unchanged and treated as black-box.  Some
of them (NEWUOA - fortran source) went through heavy modification to interface
with LOPTI.  And other (Hook-Jeevs) were completely rewritten into LOPTI native
solver.  3rd part is collection of object function and object function
modifiers.
+++</div>+++

[icon="under-construction.gif"]
CAUTION: Though LOPTI is quite usable and everything works for me,
this is still work in progress, documentation only about 40% complete,  there
is no logical sequence, API have not stabilized, build instructions are imprecise
and dependencies mostly not documented. Also it requires GCC-4.4 (not yet released) or ICC-11,
some +++C++0x+++ features are used. 


== Quick Start

--------------------
include::example.cc[]
---------------------

== Install
It is possible to use just LOPTI headers. Lopti library file used only by `NEWUOA`. 
Running `make install` installs by default into `/usr/local/include` and `/usr/local/lib`
For installation external solvers see corresponding section bellow. 


//[options="compact"]

.You will need
- Compiler. LOPTI tested only on x86-64 with with:
   *  http://gcc.gnu.org/[GCC]  with gfortran included (if you want NEWUOA solver), tested with v4.4
   * http://www.intel.com/cd/software/products/asmo-na/eng/compilers/284264.htm[ICC], vervion 11
- http://boost.org[BOOST C++ libraries], tested with 1.3.37
- http://en.wikipedia.org/wiki/Git_(software)[GIT].  Your distribution probably have package for GIT.
- http://www.cmap.polytechnique.fr/~jouve/xd3d/[XGraphic] - simple visualisation utility(optional).
- http://volnitsky.com/project/lvvlib/[lvvlib] - only array.h needed for `lvv::array` class.
- External solvers (optional), see solvers docs below.

to install:

---------------------
git clone git://github.com/lvv/lopti.git
cd lopti.git
make install
---------------------

[WARNING]
.A GCC compilation flags
==================================================
Do no use:

* `-O3`  -- hook-jeavs segfalts,  `-O2` is safe
* `-fast-math` -- newuoa and hook-jeevs can get FP errors
* `-fargument-noalias-anything` -- newuoa will segfault on exit

try `-fno-strict-aliasing` if you encounter stability problem. 

This might be specific to GCC v4.x.x

=============================================


== Definitions
*Object Function*:: a scalar function.  Single argument is an array holding parameter vector.  Also known as simply _objective_ or _OF_
*solver*::  ...
*minimizer*:: ...
*termination criteria*:: ...
*constraints*:: ...
*trust region*:: ...
*functor*:: ...
*boost::function*:: ...
*loft*:: ...


== Minimizer Class

=== Data Types
All solvers (and OF loft) are template with 1st parameter being parameter vector type. Variables step0, X0 and argmin have the same type. 
As of now,  the only type usable is `lvv::array<>`.  Can be found in `external`
directory.   It will be changed in future to support any random access container having members:

- `value_type`
- `size()`
- `begin()`
- `end()`

and plain C arrays.

=== Common Interface

- Default constructor (no arguments)
- `X0(V)` - initial point
- `S0(V)` - initial step size
- `V argmin()` - solution optimum point
- `fp_t  ymin()` - solution minimum value
- `int  iter()` - number of iterations

Type  `lvv::array<>` is ...


=== Termination Criteria
- `max_iter(int)`  - defaults to `10000`
- `rho_end(fp_t)` - defaults to `1/infinity`
- `characteristic_size(fp_t)`


== Solvers

[cols="s,^3,^2,7,11",frame="topbot",options="header"]
|=====================================================================================================================
|Solver                         | Type        | Use Derivative | Origin                   | Dependency

|NEWUOA                         | Trust Region| No             | 2002<<3>> latest from Powell, successor to UOBYQA| 
	none (converted fortran source included)

|GSL Nelder-Mead (Simplex)      | Direct      | No            | 1965<<1>>|
	GNU Scientific Library (package available for most linux distro)

|Condor                         | Trust Region| No            | Written by Dr. Ir. Frank Vanden Berghen, based on Powell's UOBYQA<<4>>|
	You need to get source or binary from author

|Hook-Jeevs                     | Direct      | No            | 1962<<2>>, C implementation by Sergey Kiselev      |
	"none (converted to native LOPTI implementation)"
|========================================================================================================================


=== GNU Scientific Library
http://www.gnu.org/software/gsl/[GSL] is high quality scientific computing
C library.  But using it is not simple, at least for simple things.
Look at http://www.gnu.org/software/gsl/manual/html_node/Multimin-Examples.html[example]
for Nelder-Mead minimizer. It is 62 line of code without object function, you will need to use cumbersome `gsl_vector` and you  have to write 
your object function in GSL specific way.

The complexities of external libraries was major reason why LOPTI was created. 



[[Nelder-Mead]]
==== GSL Nelder-Mead (simplex)

----------------------
#include <newuoa.h>
class gsl_nelder_mead_minimizer<V>
-------------------------

`LDFLAGS=-lgsl`

Old, somewhat slow but robust.  Termination criteria is set with member function `characteristic_size(double x)`
Solver iteration is not equal to eval-count, it is about 1.5*eval-count.
Rarely but it can happens, algorithm can get stuck, you can unstuck it by restarting form stuck point.
Only `double` vector,  index should start from 0. 

=== Trust Region solvers

The Trust-Region (TR) solvers are iterative methods for solving nonlinear optimization problems.
TR solvers work by approximating OF with quadratic model function, which is constructed
in such way that it passes through evaluation points near current minimum (basis).  Near means: at
distance less then `rho`, which is dynamically changed by solver for each
iteration.  To build an exact model,  `NP=(N+1)(N+2)`  evaluation points are needed, so TR
solvers at first `NP` iterations just evaluate `NP` points near `X0`. You can notice
this slow start on convergence charts.  For high `N` (>10) this can be especially noticeable. 
Instead of exact model it is possible with NEWUOA to use approximate model with less
then `(N+1)(N+2)` points. 

Uses member `rho_begin(fp_t)`, instead of `step0(V)`,  defaults to
0.2.  Because `rho` is scalar (applied equally to all directions) it is recommended
to normalize object junction with <<rescale>>.  Termination criteria is `rho_end(fp_t)`,
defaults to 1/infinity.

[[NEWUOA]]
==== NEWUOA

----------------------
#include <lopti/newuoa.h>
class newuoa_minimizer<V,[NP=2*N+1]>
----------------------

`LDFLAGS=-llopti`

One of the best solvers in this collection.
Optional second template parameters NP -  is Number-of-Points used for building model, defaults to `2*N+1` (approximate model). 
max_iter should be bigger then NP.

CAUTION: If second template paramter specifies exact model,  with N > 14, NEWUOA crashes (index out of range). 

When this solver is used `LDFLAGS=-llopti` needed. 
Any lvv::array<> vector.


[[CONDOR]]
==== CONDOR


---------------
#include <lopti/condor.h>
class condor_minimizer<V,[NP=2*N+1>
-------------------

`LDFLAGS=-lcondor`
`CXXFLAGS=-I/path/to/dir/with/condorlib-dir`

Fast for low dimensions.  Constraints capability not used. Condor internal rescaler not used (use loft rescaler).
Can use only exact  model, so it might be problematic for N > 10.
LOPTI will looking for `<condor/Vector.h>` from `condorlib` subdirectory in Condor source directory.

CAUTION: Sometimes Condor can get stuck at high precision, it is not clear if it is rounding error or algorithm limitation. 
Also sometimes aborts at FP illegal ops in the middle of optimization run. 

Only `double` vector,  index should start from 0. 

[[Hook-Jeevs]]
=== Hook-Jeevs
Native LOPTI solver, converted from Oleg Kiselev, 1998 http://www.netlib.org/c++/linalg.tgz[implementation]. Old and usually slow solver. 
But sometimes can outperform all other at not trivial high dimensions tasks. 

CAUTION: My app, segfaulted when I used this
solver.  Lowering optimization from -O3 to -O2 (gcc-4.3.2 x86_64) solved this segfault problem. 

Code still needs some cleanup, and thread safety. 
Any V type, any index start.


== Object Function
Object function are defined in so called Lopti Object FuncTor (LOFT). LOFT also allow to wrap object
function in any number and combination of LOFT, such as rescaler, logger, noise-adder,
adapter, constrain-adder-by-barrier-function,  etc. 

=== make_loft() - create loft from any callable object
`make_loft(boost::function<fp_t (*)(V& X)> callable_object)` +

Converts any to loft. Callable object can be plain function, class member function, or functor. 
A callable object passed (and possibly casted) to `make_loft` constructor.
Because `make_loft` expects a `boost::function` as its argument, it is converted to `boost::function` internally.

---------------------------------
double   plain_function(lvv::array<double,2> X);
...
mzr.loft ( make_loft<V> (&plain_function);
------------------------------


See also http://www.boost.org/doc/libs/1_37_0/doc/html/function/tutorial.html[boost::function tutorial]

LOFT should have one argument - optimization vector.  If your original function have more arguments use 
`boost::bind()`
or 
`std::bind1st(), bind2end()`

=== trace() - progress tracer
`trace(loft l,)` +

Prints on screen eval-number, seconds of last eval, X and f-value

=== xg_log() - xgraphic logger
`xg_log(loft l, minimizer<V> m)` +

Logs eval-number, f-value and X on every loft evaluation. Program `xgraphic` is
open source visualization utility which can directly input log file.  Created log
name is composed from loft name, number of dimentions and minimizer name. 
Logs are created under `./log/`

[[rescale]]
=== rescale() - normalizer
`rescale<V>(loft L, V rescale_vector)` +

Most solvers work much better if function first derivative (and second?) have
about the same order in all directions.  
The `rescale` converts object function into such normalized function. 
When solver request to evaluate 'f(X)',
`rescale` gives to wrapped 'f' modified X. 
Modification is simple multiplication by rescaling factor:  X*rescale_vector. 
When you use `rescale`, don't forget also rescale `X0`, devide it by rescale
vector and same thing for  answer verctor. 

.Rescale
--------------------------------------
typedef  array<double,2>   V;
V   R  = {{ 1, 0.0100 }};		// rescale vector  
V   X0 = {{ -1.2, 1 }}; 			
V   X_opt;				// answer
condor_minimizer<V0>	mzr;
	mzr	.loft		(rescale<V0>( trace<V0>(rosenberg<V0>()), R));
	mzr	.x0		(X/=R);
	mzr	.rho_begin	(1);
	mzr	.rho_end	(0.01);
X_opt = mzr	.argmin();
X_opt *= R;				// un-rescale
cout << "optimum at: " << X_opt << endl;
-------------------------------------


== TODO
- docs
- fix all type-puning
- remove `using` from headers
- unify and simplify termination criteria. 
- add `mkl TR solver` solver
- add `zib nlqe1` solver
- add `zib newton_test` functions
- add `gsl bfgs` solver
- add `assert` / `throw` on use uninitialized data in `minimizer` class

[bibliography]
.References
- [[[1]]] J.A. Nelder and R. Mead, 'A simplex method for function minimization', Computer Journal vol. 7 (1965), 308-315.
- [[[2]]] R. Hooke and T. A. Jeeves,  'Direct Search Solution of Numerical and Statistical Problems',  Journal of the ACM, Vol. 8, April 1961, pp. 212-229
- [[[3]]] M. J. D. Powell. 'The NEWUOA software for unconstrained optimization with derivatives'. DAMTP Report 2004/NA05, University of Cambridge, 2004.
- [[[4]]] Frank Vanden Berghen, Hugues Bersini, 'CONDOR, a new parallel, constrained extension of Powell's UOBYQA algorithm: Experimental results and comparison with the DFO algorithm',
Journal of Computational and Applied Mathematics, Elsevier, Volume 181, Issue 1, September 2005, Pages 157-175
- [[[5]]] Intel Math Kernel Library Reference Manual. http://http://www.intel.com/software/products/mkl/docs/WebHelp/osr/osr_Intro.html[Optimization Solver Routines] 

// vim: set filetype=asciidoc nu:
